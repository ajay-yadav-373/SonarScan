#!/bin/bash
DEST_PREFIX= 
BINFILE= 
ISOLINUX=
CD_MOUNT_LOC=
INITRD_MOUNT_LOC=
IS_CPIO=1
IS_GZIPPED=1
SYS_CONF=/tmp/sysconf
SYS_ROOT=/
INSTANCE="Instance001"

REFER="Refer to bootcd.log, sr_post_backup.log for details."
CURDIR=`pwd`

usage() {
    echo "Usage: cvcreateinitrd.sh <initrd name> <Log file name> <galaxy bootimage directory> [<Instance>]" | tee -a $LOG
}

#Extract the required value from the registry
get_registry_value()
{
    cat $1 | while read line
    do
        key=`echo $line | cut -d' ' -f1`
        if [ "$key" = "$2" ]; then
            echo $line | awk '{print $2}'
            break
        fi
    done
}

#copy wrapper function
#	options to copy command must start with a -
#	options to copy command are position independent
#	last argument that is not an option is the destination
#	skiplist MUST not contain any wildcards
copy() {
    #check if first argument is an option
	copt=""
    infiles=""    
	for arg in $@
	do
		case $arg in
		-*) copt="$copt $arg"; shift;;
		*) infiles="$infiles $arg"; shift;;
		esac
	done
    
    dest=`echo $infiles | awk '{print $NF}'`
    infiles=`echo $infiles | awk '{ NF--; print}'`
    outfiles=""

    file="/etc/CommVaultRegistry/Galaxy/$INSTANCE/Base/.properties"
    BaseDir=`get_registry_value $file "dHOME"`
    if [ -f $BaseDir/skiplist ]; then
        for file in $infiles
        do
            found=`grep $file $BaseDir/skiplist 2>/dev/null`
            if [ "x$found" != "x" ]; then
                echo "Found [$file] in $BaseDir/skiplist - Skipping" >> $LOG
            else
                outfiles="$outfiles $file"
            fi	
        done
    else
        outfiles=$infiles    
    fi
    echo "cp $copt $outfiles $dest" 
    `cp $copt $outfiles $dest`
}

#Assign the initrd Name
if [ x"$1" != x ]; then
    INITRD_NAME=$1
else
    INITRD_NAME=initrd
fi

#Assign LOG file name 
if [ x"$2" != x ]; then
    LOG="$2"
else
    LOG=cdtemplate.log
fi

#Assign galaxy boot location
if [ x"$3" != x ]; then
     GALAXY_BOOT=$3
else
     usage 
     exit -1  
fi

#Assign Instance
if [ x"$4" != x ]; then
	INSTANCE=$4
fi

#This function will check the type of initrd generated by the mkinitrd 
#on the system 
check_mkinitrd_type( )
{
    KERNEL_VERSION=`uname -r`
    mkinitrd /tmp/initrd.$$ $KERNEL_VERSION
    #We need to check for whether the initrd generated by mkinitrd 
    #is one of the following four types
    #1) File containing data in ext2 format (Loop back file system)
    #2) cpio archieve
    #3) gzipped cpio archieve
    #4) gzipped ext2 disk (gzipped Loop back file system)

    is_zipped=`file /tmp/initrd.$$ | grep "gzip"`
    if [ "$is_zipped" != "" ]; then
        mv /tmp/initrd.$$ /tmp/initrd.$$.gz
        gunzip /tmp/initrd.$$.gz
        IS_GZIPPED=1
    fi
    is_cpio=`file /tmp/initrd.$$ | grep "cpio"`
    if [ "$is_cpio" != "" ]; then
        IS_CPIO=1
    fi
    rm -f /tmp/initrd.$$
}

# Execute the command and check the return code
Execute()
{
    $*
    if [ $? -ne 0 ]
    then
        log="Error: execution of '$*' failed. $REFER"
        echo "$log" >> $LOG
        echo "$log" > /tmp/srfailure_reason
        exit 2
    fi
}

checkcmderr() 
{
    if [ $? -ne 0 ]; then
        return -1
    fi 
}

linkto() 
{
    ls -l $1 |awk -F " " '{ print $NF }'
}


GetIsolinuxPath() {
    ISOLINUX=/usr/lib/isolinux.bin
    [ ! -e "$ISOLINUX" ] && ISOLINUX=/usr/lib/syslinux/isolinux.bin
    [ ! -e "$ISOLINUX" ] && ISOLINUX=/usr/share/syslinux/isolinux.bin
    [ ! -e "$ISOLINUX" ] && ISOLINUX=/usr/share/lib/syslinux/isolinux.bin
    [ ! -e "$ISOLINUX" ] &&  echo "Not able to find isolinux.bin. Please install Syslinux RPM from your distributions cds. This is required to Create Galaxy 1-Touch Generic CD"
}

crt_bin_lib()
{
    if [ "$SYS_ROOT" != "/" ]; then
        rm -rf $SYS_ROOT/tmp/*
    fi
    mkdir -p $SYS_ROOT/tmp
    rm -rf $SYS_ROOT/tmp/binlist
    echo "Copy binaries and dependent libs from list [$BINFILE] count=[`cat $BINFILE | wc -l`]" >> $LOG
    for name in `cat ${BINFILE}`
    do
        echo -en "name[$name]\t" >> $LOG
        copy=""
        if [ ! -x $name ]; then
            bn=`basename $name`
            fname=`which $bn 2>/dev/null`
            if [ -x "$fname" ]; then
                copy=$fname
            fi
        else
            copy=$name
        fi
        if [ "x$copy" != "x" ]; then
            echo "Copy bin [$copy]" >> $LOG
            copy_with_link_target_strip $copy
            echo $copy >> $SYS_ROOT/tmp/binlist 
        else
            echo "not found" >> $LOG
        fi
    done    
    #
    #`cat /tmp/binlist | xargs /usr/bin/ldd | grep so | sed -e '/^[^\t]/ d' | sed -e 's/\t//' | sed -e 's/.*=..//' | sed -e 's/ (0.*)//' | sort -u > /tmp/lib_list`
    # This line above may crash due to memory issues, hence split it

    rm -rf $SYS_ROOT/tmp/list1 $SYS_ROOT/tmp/list7
    
    cat $SYS_ROOT/tmp/binlist | while read line
    do
        ldd $line | grep so >> $SYS_ROOT/tmp/list1                   #for each binary, list all libraries required
        ldd $line | grep so > $SYS_ROOT/tmp/list2                    #for each binary, list all libraries required	
        /bin/sed -e '/^[^\t]/ d' $SYS_ROOT/tmp/list2 > $SYS_ROOT/tmp/list3    #...remove trailing tabs
        /bin/sed -e 's/\t//' $SYS_ROOT/tmp/list3 > $SYS_ROOT/tmp/list4
        /bin/sed -e 's/.*=..//' $SYS_ROOT/tmp/list4 > $SYS_ROOT/tmp/list5     #...remove library name until '=> '
        /bin/sed -e 's/ (0.*)//' $SYS_ROOT/tmp/list5 >> $SYS_ROOT/tmp/list7   #...remove numerals (address) - what remains is only full path of library
    done
    /bin/sed -e '/^$/d' $SYS_ROOT/tmp/list7 > $SYS_ROOT/tmp/list8	
    sort -u $SYS_ROOT/tmp/list8 > $SYS_ROOT/tmp/lib_list
    rm -rf $SYS_ROOT/tmp/list1 $SYS_ROOT/tmp/list2 $SYS_ROOT/tmp/list3 $SYS_ROOT/tmp/list4 $SYS_ROOT/tmp/list5 $SYS_ROOT/tmp/list7 $SYS_ROOT/tmp/list8
    rm -rf $SYS_ROOT/tmp/binlist

    echo "Now copy dependent libs from list [$SYS_ROOT/tmp/lib_list] count=[`cat $SYS_ROOT/tmp/lib_list | wc -l`]" >> $LOG
    for name in `cat $SYS_ROOT/tmp/lib_list`
    do
        echo "Copy lib [$name]" >> $LOG
        copy_with_link_target_strip $name
    done    


    file="/etc/CommVaultRegistry/Galaxy/$INSTANCE/iDataAgent/.properties"
    CopyCustomLibs=`get_registry_value $file "nSRCopyCustomLibs"`

    # There could be a case where libraries needed for bash to run might have been
    # moved to a non-standard location. Stage-2 kernel will fail to load
    # Make a copy of these libraries to its standard location
    ldd -r /bin/bash | grep so > $SYS_ROOT/tmp/list2
    /bin/sed -e '/^[^\t]/ d' $SYS_ROOT/tmp/list2 > $SYS_ROOT/tmp/list3    #...remove trailing tabs
    /bin/sed -e 's/\t//' $SYS_ROOT/tmp/list3 > $SYS_ROOT/tmp/list4
    /bin/sed -e 's/.*=..//' $SYS_ROOT/tmp/list4 > $SYS_ROOT/tmp/list5     #...remove library name until '=> '
    /bin/sed -e 's/ (0.*)//' $SYS_ROOT/tmp/list5 > $SYS_ROOT/tmp/list6    #...remove numerals (address) - what remains is only full path of library
    cat $SYS_ROOT/tmp/list6 | grep -v "^$" > $SYS_ROOT/tmp/list7          #...remove blank lines
    rm -rf $SYS_ROOT/tmp/list2 $SYS_ROOT/tmp/list3 $SYS_ROOT/tmp/list4 $SYS_ROOT/tmp/list5 $SYS_ROOT/tmp/list6 

    ARCH=`uname -m`
    if [ "$ARCH" == "x86_64" ]; then
        DLIB="lib64"
    else
        DLIB="lib"
    fi        
    if [ -n "$CopyCustomLibs" -a "$CopyCustomLibs" == "1" ]; then
        cat $SYS_ROOT/tmp/list7 | while read line
        do
            echo "Custom Lib : Copied [$line] => [$DEST_PREFIX/$DLIB] for stage-2 initrd"
            copy $line ${DEST_PREFIX}/$DLIB
        done        
    fi
    #In addition to this, we will need the directory names to update LD_LIBRARY_PATH during recovery
    cat $SYS_ROOT/tmp/list7 | xargs -n 1 dirname | sort -u | grep -v "^/lib/" | grep -v "^/lib64" > $SYS_ROOT/tmp/list8
    while read dir
    do
        path=$path:$dir
    done < $SYS_ROOT/tmp/list8
    echo "Saving extra LD_LIBRARY_PATH variables [$path]" >> $LOG
    rm -rf $SYS_ROOT/tmp/list7 $SYS_ROOT/tmp/list8 

    file="/etc/CommVaultRegistry/Galaxy/$INSTANCE/Base/.properties"
    BaseDir_l=`get_registry_value $file "dHOME"`
    if [ "`uname -m`" == "x86_64" ]; then
        BaseDir=${BaseDir_l}64
    else
        BaseDir=${BaseDir_l}32
    fi
    echo "Prefixing [$BaseDir:$BaseDir_l] to extra LD_LIBRARY_PATH" >> $LOG
    echo "$BaseDir:$BaseDir_l:$path" > $SYS_CONF/extra_ld_library_paths

    #Disable HLE
    if [ -d "/lib64/noelision" ]; then
        echo "$BaseDir:$BaseDir_l:$path:/lib64:/lib64/noelision" > $SYS_CONF/extra_ld_library_paths
    fi

    if [ -n "$path" ]; then
        echo "Core system libraries located in non standard paths [$path]. 1-Touch restore will need these paths to be backed up" >> $LOG 
    fi        

    num=`cat $SYS_ROOT/tmp/lib_list | wc -l`
    if [ $num -eq 0 ]; then
        log="Failed to prepare list of required libraries! $REFER"
        echo "$log" >> $LOG
        echo "$log" > /tmp/srfailure_reason
        exit 1    
    fi    
    rm -rf $SYS_ROOT/tmp/lib_list

    if [ "$SYS_ROOT" != "/" ]; then
        rm -rf $SYS_ROOT/tmp/*
    fi
}

copy_with_link_target_strip()
{
    name=$1
    source_dir=$2
    filename=`basename $name` 
    base=`dirname ${name}`
    if [ -L ${source_dir}/${name} ]; then    
         linkname=`linkto ${source_dir}/${name}`
         LnkDirName=`dirname $linkname`
         if [ "x$LnkDirName" == "x." ]; then
              install -D ${source_dir}/${base}/${linkname} ${DEST_PREFIX}/${base}/${linkname}
              file ${DEST_PREFIX}/${base}/${linkname} | grep "ELF" > /dev/null
              if [ $? -eq 0 ]; then    
                strip --remove-section=.comment --remove-section=.note ${DEST_PREFIX}/${base}/${linkname} 2>/dev/null
              fi      
         else
              echo $linkname | grep "^\.\." > /dev/null
              if [ $? -eq 0 ]; then
                   install -D ${source_dir}/${base}/${linkname} ${DEST_PREFIX}/${base}/${linkname}
                   file ${DEST_PREFIX}/${base}/${linkname} | grep "ELF" > /dev/null
                   if [ $? -eq 0 ]; then    
                        strip --remove-section=.comment --remove-section=.note ${DEST_PREFIX}/${base}/${linkname} 2>/dev/null
                   fi         
              else
                   install -D ${source_dir}/${linkname} ${DEST_PREFIX}/${linkname}
                   base=""
                   file ${DEST_PREFIX}/${linkname} | grep "ELF" > /dev/null
                   if [ $? -eq 0 ]; then    
                        strip --remove-section=.comment --remove-section=.note ${DEST_PREFIX}/${linkname} 2>/dev/null
                   fi
              fi
         fi
         if [ ! -e ${DEST_PREFIX}/${name} ]; then
              ln -s ${linkname} ${DEST_PREFIX}/${name}
         fi
    else
         install -D ${source_dir}/$name ${DEST_PREFIX}/${base}/${filename}
         file ${DEST_PREFIX}/${base}/${filename} | grep "ELF" > /dev/null
         if [ $? -eq 0 ]; then    
            strip --remove-section=.comment --remove-section=.note ${DEST_PREFIX}/${base}/${filename}
         fi
    fi
}

copy_with_link_target()
{
    name=$1
    source_dir=$2
    filename=`basename $name` 
    base=`dirname ${name}`
    if [ -L ${source_dir}/${name} ]; then    
         linkname=`linkto ${source_dir}/${name}`
         LnkDirName=`dirname $linkname`
         if [ "x$LnkDirName" == "x." ]; then
              install -D ${source_dir}/${base}/${linkname} ${DEST_PREFIX}/${base}/${linkname}
         else
              echo $linkname | grep "^\.\." > /dev/null
              if [ $? -eq 0 ]; then
                   install -D ${source_dir}/${base}/${linkname} ${DEST_PREFIX}/${base}/${linkname}
              else
                   install -D ${source_dir}/${linkname} ${DEST_PREFIX}/${linkname}
                   base=""
              fi
         fi
         if [ ! -e ${DEST_PREFIX}/${name} ]; then
              ln -s ${linkname} ${DEST_PREFIX}/${name}
         fi
    else
         install -D ${source_dir}/$name ${DEST_PREFIX}/${base}/${filename}
    fi
}

copy_simpana_libs()
{
    BIN_LIST="bootimage/INITRD/onetouchutil
              bootimage/INITRD/srdiskenumerate" 
    for BIN in $BIN_LIST 
    do    
        ldd $BIN  2>&1 > /dev/null
        if [ $? -eq 0 ]; then
             ldd $BIN 2>/dev/null | while read line
             do
                 libname=`echo $line | awk '{print $3}'`
                 if [ x$libname == "xnot" ]; then
                      #This library was not detected on the host system on which the bootcd
                      #is being created. We check for this under the location supplied for
                      #SUSE bootcd.     
                      base_lib=`echo $line | awk '{print $1}'`
                      if [ -f "/lib/$base_lib" ]; then
                           libname="/lib/$base_lib" 
                      elif [ -f "/usr/lib/$base_lib" ]; then
                           libname="/usr/lib/$base_lib"
                      else 
                           echo -e "\t\tA missing shared library file detected for $name" >> $LOG
                           continue
                      fi
                 fi 
                 if [ x"$libname" == x ]; then
                      continue
                 fi
                 lib_base_name=`basename $libname`
                 lib_dir_name=`dirname $libname` 
                 if [ ! -e $libname ]; then
                      # if a library is not found under /usr/lib/<libname> we go ahead and search for it 
                      # in the following order 
                      if [ -f "/lib/$lib_base_name" ]; then
                           libname="/lib/$lib_base_name" 
                      elif [ -f "/usr/lib/$lib_base_name" ]; then
                           libname="/usr/lib/$lib_base_name"
                      else 
                           continue
                      fi
                 fi 
                 if [ -L $libname ]; then
                      base=`dirname ${libname}`
                      linkname=`linkto ${libname}`
                      LnkDirName=`dirname $linkname`
                      if [ x$LnkDirName == "x." ]; then
                           install -D ${base}/${linkname} ${DEST_PREFIX}/${lib_dir_name}/${linkname}
                           base=$lib_dir_name
                      else
                           echo $linkname | grep "^\.\." > /dev/null
                           if [ $? -eq 0 ]; then
                                install -D ${base}/${linkname} ${DEST_PREFIX}/${lib_dir_name}/${linkname}
                                base=$lib_dir_name
                           else
                                install -D ${linkname} ${DEST_PREFIX}/${linkname}
                                base=""
                           fi
                      fi
                      if [ ! -e ${DEST_PREFIX}/${base}/${lib_base_name} ]; then
                           ln -s ${linkname} ${DEST_PREFIX}/${base}/${lib_base_name}
                      fi
                 else
                      install -D ${libname} ${DEST_PREFIX}/${lib_dir_name}/${lib_base_name} 
                 fi 
             done   
        fi
    done
}

is_galxy_lib()
{
    libname=$1
    file="/etc/CommVaultRegistry/Galaxy/$INSTANCE/Base/.properties"
    Galaxy_Home=`get_registry_value $file "dGALAXYHOME"`
    lib_base_name=`dirname $libname`
    if [ "$lib_base_name" == "$Galaxy_Home/Base" ]; then
         return 0
    fi
    return -1
}

copy_simpana_dependent_libs()
{
    rm -rf $SYS_ROOT/tmp/cvlib_list
    file="/etc/CommVaultRegistry/Galaxy/$INSTANCE/Base/.properties"
    Galaxy_Home=`get_registry_value $file "dGALAXYHOME"`
    BaseDir=`get_registry_value $file "dHOME"`
    export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:$BaseDir

    #The story behind the next big line of code
    #find all files under Base dir that, and list all library dependencies
    #... remove trailing tab and spaces, remove '=> ', remove address field
    #... what remains is name of library - check if its not packaged within Base dir
    #... unique sort the list
    findopt=' -L '
    find -L /tmp > /dev/null 2>&1
    if [ $? -ne 0 ]; then
        echo "find does not support -L" >> $LOG
        findopt=""
		BaseDir2="${BaseDir}/"
    else
		BaseDir2="${BaseDir}"
    fi
    find $findopt $BaseDir2 -type f -exec ldd {} \; \
        | grep so | /bin/sed -e '/^[^\t]/ d' | /bin/sed -e 's/\t//' | /bin/sed -e 's/.*=..//' | /bin/sed -e 's/ (0.*)//' \
        | grep -v "$BaseDir" | grep -iv "not found" | sort -u | /bin/sed -e '/^$/d' >> $SYS_ROOT/tmp/cvlib_list
    echo "Copying libs required for simpana but not packaged within [$BaseDir] from=[$SYS_ROOT/tmp/cvlib_list] count=[`cat $SYS_ROOT/tmp/cvlib_list | wc -l`]" >> $LOG

    for name in `cat $SYS_ROOT/tmp/cvlib_list`
    do
        echo "cv deplib: copy [$name]" >> $LOG
        copy_with_link_target_strip $name
#lib_base_name=`dirname $name`
#       if [ "$lib_base_name" != "$Galaxy_Home/Base" ]; then
#            copy_with_link_target $name
#       fi    
    done
    num=`cat $SYS_ROOT/tmp/cvlib_list | wc -l`
    if [ $num -eq 0 ]; then
        log="Failed to prepare list of required libraries for cv binaries. $REFER"
        echo "$log" >> $LOG
        echo "$log" > /tmp/srfailure_reason
        exit 1    
    fi    
    rm -rf $SYS_ROOT/tmp/cvlib_list
}

##################################################
############    Performing Cleanup    ############
##################################################
if [ -f ./initrd.tar ]; then
    echo -e "Removing ./initrd.tar"
    rm -rf ./initrd.tar
    echo -en \\033[50G >> $LOG
    echo -e "Done"
fi

if [ -f /tmp/initrd.cpio.debug ]; then
    IS_CPIO=1
fi

if [ -f /tmp/initrd.ext2.debug ]; then
    IS_CPIO=0
fi

if [ -f /tmp/initrd.gzip.debug ]; then
    IS_GZIPPED=1
fi

if [ -f /tmp/initrd.nozip.debug ]; then
    IS_GZIPPED=0
fi

echo "mkinitrd check done: IS_GZIPPED=$IS_GZIPPED IS_CPIO=$IS_CPIO"

##################################################
#####           Preparing initrd             #####
##################################################
DEST_PREFIX=/tmp/INITRD
ALT_SYSCONF_DIR=`get_registry_value "/etc/CommVaultRegistry/Galaxy/$INSTANCE/FileSystemAgent/.properties" "sSystemStateDir"`
if [ -n "$ALT_SYSCONF_DIR" ]; then
    Log "Extracted sSystemStateDir [ $ALT_SYSCONF_DIR ]"
    SYS_ROOT=$ALT_SYSCONF_DIR
    SYS_CONF="$ALT_SYSCONF_DIR/sysconf"
    DEST_PREFIX="$ALT_SYSCONF_DIR/INITRD"
fi

mkdir -p ${DEST_PREFIX}
if [ $? -ne 0 -o ! -d ${DEST_PREFIX} ]; then
    log="Error: Failed to create staging directory for system state [${DEST_PREFIX}]. $REFER"
    echo "$log" >> $LOG
    echo "$log" > /tmp/srfailure_reason
    exit 1
fi


BINFILE=$GALAXY_BOOT/FILENAME/cdlist
REVFILE=$GALAXY_BOOT/../revision.txt
echo -e "\nCopying files for INITRD"
crt_bin_lib
unalias cp

ARCH=`uname -a | grep "x86_64"`
if [ x"$ARCH" = x ]; then
     #The Architecture is not x86_64
     copy -rf "/lib/libnss*" ${DEST_PREFIX}/lib
     copy -rf "/usr/lib/openssl-1.0.0/" ${DEST_PREFIX}/usr/lib/
     mkdir -p ${DEST_PREFIX}/lib/i386-linux-gnu/
     copy -rf "/lib/i386-linux-gnu/libnss*" ${DEST_PREFIX}/lib/i386-linux-gnu
     copy -rf "/usr/lib/i386-linux-gnu/openssl-1.0.0/" ${DEST_PREFIX}/usr/lib/i386-linux-gnu
     copy_with_link_target /lib/ld-linux.so.2
     copy_with_link_target /lib/i386-linux-gnu/ld-2.15.so
else 
     #The Architecture is x86_64
     mkdir -p ${DEST_PREFIX}/lib64
     copy -rf "/lib64/libnss*" ${DEST_PREFIX}/lib64
     mkdir -p ${DEST_PREFIX}/lib/x86_64-linux-gnu/
     copy -rf "/lib/x86_64-linux-gnu/libncurses*" ${DEST_PREFIX}/lib/x86_64-linux-gnu
     copy -rf "/lib64/libncurses*" ${DEST_PREFIX}/lib64
     copy -rf "/lib64/libtinfo*" ${DEST_PREFIX}/lib64
     copy_with_link_target /lib64/ld-linux-x86-64.so.2
     copy -rf "/lib/x86_64-linux-gnu/libnss*" ${DEST_PREFIX}/lib/x86_64-linux-gnu
     copy -rf "/usr/lib/x86_64-linux-gnu/openssl-1.0.0/" ${DEST_PREFIX}/usr/lib/x86_64-linux-gnu
fi

#copy the dependent libraries for simpana executables to the initrd.
copy_simpana_libs

module_list=""
module_list_ide=`modprobe --show-depends --ignore-install ide-cd 2> /dev/null | grep insmod | awk '{print $2}'`
module_list_sr=`modprobe --show-depends --ignore-install sr_mod 2> /dev/null |  grep insmod | awk '{print $2}'`
module_list_sd=`modprobe --show-depends --ignore-install sd_mod 2> /dev/null |  grep insmod | awk '{print $2}'`
module_list_cmd64x=`modprobe --show-depends --ignore-install cmd64x 2> /dev/null | grep insmod | awk '{print $2}'`
nfs_mod_list=`modprobe --show-depends --ignore-install nfs 2> /dev/null | grep insmod | awk '{print $2}'`
parport_mod_list=`modprobe --show-depends --ignore-install parport 2> /dev/null | grep insmod | awk '{print $2}'` 
module_list="$module_list_ide $module_list_sr $module_list_sd $module_list_cmd64x $nfs_mod_list $parport_mod_list"
#Add the commonly required modules to the modules.lst file
for mod_name in $module_list
do
     file_name=`basename $mod_name| cut -d '.' -f 1` 
     echo $file_name >> ${DEST_PREFIX}/modules.lst
done

mkdir ${DEST_PREFIX}/dev 2>/dev/null
mkdir ${DEST_PREFIX}/etc 2>/dev/null
mkdir ${DEST_PREFIX}/proc 2>/dev/null
mkdir ${DEST_PREFIX}/tmp  2>/dev/null
mkdir ${DEST_PREFIX}/proc/efi 2>/dev/null
mkdir ${DEST_PREFIX}/proc/efi/vars 2> /dev/null 

#We create only the very commonly required nodes under the /dev directory
copy -R /dev/console ${DEST_PREFIX}/dev/
copy -R /dev/core ${DEST_PREFIX}/dev/
fdlist=`ls -d /dev/fd*`
if [ x"$fdlist" != x ]; then
    for fd in $fdlist
    do
        copy -R $fd ${DEST_PREFIX}/dev/ 
    done 
fi
copy -R /dev/gpmctl ${DEST_PREFIX}/dev/
copy -R /dev/initctl ${DEST_PREFIX}/dev/
copy -R /dev/input ${DEST_PREFIX}/dev/
copy -R /dev/kmsg ${DEST_PREFIX}/dev/
copy -R /dev/log ${DEST_PREFIX}/dev/
looplist=`ls /dev/loop*`
if [ x"$looplist" != x ]; then
    for lpdev in $looplist
    do
        copy -R $lpdev ${DEST_PREFIX}/dev/
    done
fi
copy -R /dev/lp0 ${DEST_PREFIX}/dev/
copy -R /dev/mapper ${DEST_PREFIX}/dev/
copy -R /dev/device-mapper ${DEST_PREFIX}/dev/
copy -R /dev/md0 ${DEST_PREFIX}/dev/
copy -R /dev/mem ${DEST_PREFIX}/dev/
copy -R /dev/net ${DEST_PREFIX}/dev/
copy -R /dev/null ${DEST_PREFIX}/dev/
copy -R /dev/nvram ${DEST_PREFIX}/dev/
copy -R /dev/oldmem ${DEST_PREFIX}/dev/
copy -R /dev/par0 ${DEST_PREFIX}/dev/
copy -R /dev/parport0 ${DEST_PREFIX}/dev/ 
copy -R /dev/parport1 ${DEST_PREFIX}/dev/ 
copy -R /dev/parport2 ${DEST_PREFIX}/dev/ 
copy -R /dev/parport3 ${DEST_PREFIX}/dev/ 
copy -R /dev/port ${DEST_PREFIX}/dev/ 
copy -R /dev/ppp ${DEST_PREFIX}/dev/ 
copy -R /dev/ptmx ${DEST_PREFIX}/dev/ 
copy -R /dev/pts ${DEST_PREFIX}/dev/ 
ramlist=`ls /dev/ram*`
if [ x"$ramlist" != x ]; then
    for ram in $ramlist
    do
        copy -R $ram ${DEST_PREFIX}/dev/
    done
fi
mkdir ${DEST_PREFIX}/dev/shm
copy -R /dev/snapshot ${DEST_PREFIX}/dev/ 
copy -R /dev/stdin ${DEST_PREFIX}/dev/
copy -R /dev/stdout ${DEST_PREFIX}/dev/
copy -R /dev/stderr ${DEST_PREFIX}/dev/
copy -R /dev/systty ${DEST_PREFIX}/dev/
ttylist=`ls /dev/tty*`
if [ x"$ttylist" != x ]; then
    for tty in $ttylist
    do
        copy -R $tty ${DEST_PREFIX}/dev/
    done
fi
copy -R /dev/urandom ${DEST_PREFIX}/dev/
vcslist=`ls /dev/vcs*`
if [ x"$vcslist" != x ]; then
    for vcs in $vcslist
    do
        copy -R $vcs ${DEST_PREFIX}/dev/
    done
fi
copy -R /dev/zero ${DEST_PREFIX}/dev/
#copy grub directories
mkdir -p ${DEST_PREFIX}/usr/lib
copy -rf /usr/lib/grub ${DEST_PREFIX}/usr/lib
mkdir -p ${DEST_PREFIX}/usr/share
copy -rf /usr/share/grub ${DEST_PREFIX}/usr/share

#copy the /usr/share/terminfo directory
mkdir -p ${DEST_PREFIX}/usr/share/
copy -rf /usr/share/terminfo ${DEST_PREFIX}/usr/share/
mkdir -p ${DEST_PREFIX}/lib/terminfo
copy -rf /lib/terminfo ${DEST_PREFIX}/lib/
mkdir -p ${DEST_PREFIX}/usr/lib/locale
copy -rf /usr/lib/locale/en_US* ${DEST_PREFIX}/usr/lib/locale
mkdir -p ${DEST_PREFIX}/usr/share/locale
copy -rf /usr/share/locale/en_US* ${DEST_PREFIX}/usr/share/locale
cp -rf /usr/share/terminfo ${DEST_PREFIX}/usr/share/
#cp -rf /usr/share/locale ${DEST_PREFIX}/usr/share/

#copy termcap
copy_with_link_target /etc/termcap
copy_with_link_target /etc/nsswitch.conf 
copy_with_link_target /etc/protocols


copy_with_link_target /etc/host.conf  
copy_with_link_target /etc/nsswitch.conf
cp -p /etc/passwd ${DEST_PREFIX}/etc
copy_with_link_target /etc/group  
cp -p /etc/shadow ${DEST_PREFIX}/etc
copy_with_link_target /etc/mime.types  
copy_with_link_target /etc/localtime
copy_with_link_target /etc/shells  
copy_with_link_target /etc/issue
copy_with_link_target /etc/services
copy_with_link_target /etc/rc.d/init.d/functions
copy_with_link_target /etc/udev/udev.conf
copy_with_link_target /etc/sysconfig/kernel
copy_with_link_target /etc/scsi_id.config
copy_with_link_target /etc/lvm/lvm.conf
copy_with_link_target /etc/mke2fs.conf

if [ -d /usr/share/hwdata ]; then
     mkdir -p ${DEST_PREFIX}/usr/share/hwdata
     copy -rf /usr/share/hwdata/* ${DEST_PREFIX}/usr/share/hwdata	 
fi	

if [ -e /etc/magic ]; then
     copy_with_link_target /etc/magic
fi   

copy_with_link_target /etc/issue
copy -a /etc/*release ${DEST_PREFIX}/etc

#Copy the magic files 
mkdir -p ${DEST_PREFIX}/usr/share/misc/
copy -rf /usr/share/misc/magic* ${DEST_PREFIX}/usr/share/misc/

touch ${DEST_PREFIX}/etc/fstab
touch ${DEST_PREFIX}/etc/raidtab
#Run the depmod command to create the dependency file.
depmod
#Add the commonly required PCI/USB configuration files to the initrd image.
VER=`uname -r`
mkdir -p ${DEST_PREFIX}/lib/modules/$VER
copy -a /lib/modules/$VER/modules.dep ${DEST_PREFIX}/lib/modules/$VER
copy -a /lib/modules/$VER/modules.pcimap ${DEST_PREFIX}/lib/modules/$VER
copy -a /lib/modules/$VER/modules.usbmap ${DEST_PREFIX}/lib/modules/$VER
copy -a /lib/modules/$VER/modules.alias ${DEST_PREFIX}/lib/modules/$VER
copy -a /lib/modules/$VER/modules.symbols ${DEST_PREFIX}/lib/modules/$VER
copy -a /lib/rsyslog ${DEST_PREFIX}/lib
copy -a /lib64/rsyslog ${DEST_PREFIX}/lib64
copy -a /etc/rsyslog.conf ${DEST_PREFIX}/etc

tar -cvf kernel_modules.tar /lib/modules/$VER/ --exclude source --exclude build --exclude weak-updates

#weak updates usually reference modules of a different kernel version. pick them up by dereferencing symbolic links
tar rvfh kernel_modules.tar /lib/modules/$VER/weak-updates
gzip kernel_modules.tar
mv kernel_modules.tar.gz ${DEST_PREFIX}/kernel_modules.tgz

#copy modules specific files
if [ -f /etc/modules.conf ]; then
    copy /etc/modules.conf ${DEST_PREFIX}/etc/
else
    copy -a "/etc/modprobe*" ${DEST_PREFIX}/etc/
fi
if [ -f /etc/depmod.conf ]; then
    copy /etc/depmod.conf ${DEST_PREFIX}/etc/
else
    copy -a "/etc/depmod*" ${DEST_PREFIX}/etc/
fi

#copy orig modprobe/depmod if ksplice is installed
copy -a /sbin/*ksplice* ${DEST_PREFIX}/sbin

ARCH=`uname -m`
if [ "$ARCH" == "x86_64" ]; then
     LIBRARY_DEST_PATH=lib64
else
     LIBRARY_DEST_PATH=lib
fi

if [ "$ARCH" = "ia64" ]; then
    CreateIA64Bootmenu
fi

#Copy the simpana dependent system libaries
if [ ! -e /tmp/1touch_skip_galaxy_dependent_libs ]; then
     copy_simpana_dependent_libs
fi

#Copy the list of drivers to the system state. 
#This cannot be done until depmod has been invoked above.
list=`lsmod | awk '{print $1}' | grep -v "Module"`
for mod in $list
do
    driverlist=`modprobe --show-depends --ignore-install $mod | grep -v "modprobe" | awk '{print $2}'`
    for driver in $driverlist
    do
        drvr=`basename $driver`
        echo "$drvr" >>$SYS_CONF/initrd.list
    done
done


#Copy the system state to the initrd image
mkdir -p ${DEST_PREFIX}/system_state
cp -rf $SYS_CONF ${DEST_PREFIX}/system_state

#Determine whether the user wants to expand the holes or leave them as it is.
file="/etc/CommVaultRegistry/Galaxy/$INSTANCE/iDataAgent/.properties"
expand_hole=`get_registry_value $file "OptimizeRunLengths"`
if [ "x$expand_hole" = "x" ]; then
     expand_hole="512"       
fi      
echo "OptimizeRunLengths $expand_hole" >> ${DEST_PREFIX}/system_state/sysconf/registry

#Copy the udev configuration files
mkdir -p ${DEST_PREFIX}/etc/udev/
copy -rf /etc/udev/rules.d ${DEST_PREFIX}/etc/udev/

mkdir -p ${DEST_PREFIX}/lib/
copy -rf /lib/udev  ${DEST_PREFIX}/lib/
copy -rf /lib/firmware ${DEST_PREFIX}/lib/

mkdir -p ${DEST_PREFIX}/etc/sysconfig
if [ -e /etc/sysconfig/udev  ]; then
     copy -rf /etc/sysconfig/udev  ${DEST_PREFIX}/etc/sysconfig
fi   

mkdir -p  ${DEST_PREFIX}/etc/udev/scripts/
if [ -e /etc/udev/scripts ]; then
    copy -rf /etc/udev/scripts/* ${DEST_PREFIX}/etc/udev/scripts/
fi                             

rpm -q udev
if [ $? -eq 0 ]; then
    rpm -q --filesbypkg udev | grep -v man | grep -v doc | awk '{print $2}' | tar -zcvf udev.tgz -T -
    echo "udev package found in rpm." >> $LOG
    mv udev.tgz ${DEST_PREFIX}/
else
	dpkg -L udev|grep -v man|grep -v doc|awk '{print $1}' > /tmp/files
    #remove directories
    rm /tmp/files1
	while read line
    do
        if [ -d $line ]
        then
            continue
        fi
        echo $line >> /tmp/files1
    done < /tmp/files
    cat /tmp/files1|tar -zcvf udev.tgz -T -
    rm -rf /tmp/files
    rm -rf /tmp/files1
    mv udev.tgz ${DEST_PREFIX}/	
    echo "udev package found in dpkg." >> $LOG
fi

if [ -e /lib/mkinitrd/ ]; then
     copy -rf /lib/mkinitrd/ ${DEST_PREFIX}/lib/
fi

#Copy the dhcp and networking specific configuration files.
mkdir -p ${DEST_PREFIX}/etc/sysconfig/network-scripts
copy -rf /etc/sysconfig/network-scripts/* ${DEST_PREFIX}/etc/sysconfig/network-scripts
mkdir -p ${DEST_PREFIX}/etc/init.d
copy -rf /etc/init.d/functions ${DEST_PREFIX}/etc/init.d

#Copy the iscsi specific configuration files to initrd image.
if [ -d /etc/iscsi ]; then
     copy -rf /etc/iscsi  ${DEST_PREFIX}/etc
fi
if [ -d /var/lib/iscsi ]; then
     mkdir -p ${DEST_PREFIX}/var/lib
     copy -rf /var/lib/iscsi ${DEST_PREFIX}/var/lib	  
fi

#Copy mpath override file if present
copy -f /tmp/use_mpath_flag ${DEST_PREFIX}/tmp

#Copy bootloader flag if present
copy -f $SYS_CONF/efi_backup_flag ${DEST_PREFIX}/tmp

#Copy revision and other info
mkdir -p ${DEST_PREFIX}/revinfo
copy -f $REVFILE ${DEST_PREFIX}/revinfo
echo "Linux 1-Touch system state backup created on : `date` " > ${DEST_PREFIX}/revinfo/timestamp

copy -r "/sbin/ldconfig.*" ${DEST_PREFIX}/sbin

#Copy devmapper and multipath binaries, libs and configuration files
mkdir -p ${DEST_PREFIX}/lib/modules/$VER/kernel/drivers/md
copy -f /lib/modules/`uname -r`/kernel/drivers/md/dm-* ${DEST_PREFIX}/lib/modules/$VER/kernel/drivers/md
FILES=" /etc/init.d/boot.device-mapper
        /sbin/devmap_mknod.sh
        /etc/init.d/boot.multipath
        /etc/init.d/multipathd
        /etc/udev
        /etc/udev/rules.d/71-multipath.rules
        /etc/udev/rules.d/72-multipath-compat.rules
        /etc/udev/rules.d/96-multipath-late.rules
        /var/cache/multipath
        /etc/multipath.conf
        /var/lib/multipath/bindings
        /etc/multipath/bindings
        /etc/multipath-bindings.conf
        /lib/libsysfs.so.2
        /lib/libvolume_id.so.1
        /lib/libmultipath.so
        /lib64/libmultipath.so
        /etc/multipath
        /etc/rc.d/init.d/multipathd
        /lib/udev/rules.d/40-multipath.rules
        /sbin/cciss_id
        /sbin/mpathconf
        /sbin/multipath
        /sbin/multipathd
        /lib/udev
        /lib/udev/rules.d
        /lib/udev/rules.d/10-dm.rules
        /lib/udev/rules.d/13-dm-disk.rules
        /lib/udev/rules.d/95-dm-notify.rules
        /sbin/dmsetup
        /sbin/dmeventd
        /opt/dell/srvadmin/sbin/dataeng.hotplug
        /usr/bin/grub-mkrelpath
        /usr/bin/grub-mkimage
        /usr/sbin/grub-setup
        /usr/sbin/grub-probe
        /usr/sbin/grub-mkconfig
        /usr/sbin/grub-mkdevicemap
        /lib/udev/dmsetup_env
        /lib/udev/kpartx_id
        /lib/udev/rules.d
        /lib/udev/rules.d/95-kpartx.rules
        /lib/x86_64-linux-gnu/libaio.so.1.0.1
        /lib/i386-linux-gnu/libaio.so.1.0.1
        /lib/libmultipath.so.0
        
	  "
for file in ${FILES}
do
    if [ -e $file ]; then
   	     copy_with_link_target $file
    fi
done
FILES=`ls /lib*/multipath/* /usr/lib*/multipath/*`
for file in ${FILES}
do
    copy_with_link_target $file
done
FILES=`ls /lib*/libdevmapper* /usr/lib*/libdevmapper*`
for file in ${FILES}
do
    copy_with_link_target $file
done
FILES=`ls /lib*/libaio* /usr/lib*/libaio*`
for file in ${FILES}
do
    copy_with_link_target $file
done
FILES=`ls /lib*/device-mapper/* /usr/lib*/device-mapper/**`
for file in ${FILES}
do
    copy_with_link_target $file
done
FILES=`ls /lib*/libgcc_* /usr/lib*/libgcc_* /lib*/libstdc* /usr/lib*/libstdc*`
for file in ${FILES}
do
    copy_with_link_target $file
done

if [ -f /etc/redhat-release -o -f /etc/SuSE-release ]; then
    FILES=`rpm -q --filesbypkg systemd | awk '{print $2}' | grep -v "\/usr\/share" | grep -v "X11"`
    for file in ${FILES}
    do
        copy_with_link_target $file
    done
    FILES=`rpm -q --filesbypkg lvm2 | awk '{print $2}' | grep -v "\/usr\/share" | grep -v "X11"`
    for file in ${FILES}
    do
        copy_with_link_target $file
    done
    FILES=`rpm -q --filesbypkg device-mapper | awk '{print $2}' | grep -v "\/usr\/share" | grep -v "X11"`
    for file in ${FILES}
    do
        copy_with_link_target $file
    done
    FILES=`rpm -q --filesbypkg rsyslog | awk '{print $2}' | grep -v "\/usr\/share" | grep -v "X11"`
    for file in ${FILES}
    do
        copy_with_link_target $file
    done
    FILES=`ls /usr/lib/udev/rules.d/*`
    for file in ${FILES}
    do
        copy_with_link_target $file
    done
fi

grep -i "ubuntu" /etc/*release
ret=$?
if [ $ret -eq 0 ]; then
    FILES=`dpkg-query -L systemd | grep -v "\/usr\/share"`
    for file in ${FILES}
    do
        copy_with_link_target $file
    done
    FILES=`dpkg-query -L udev | grep -v "\/usr\/share"`
    for file in ${FILES}
    do
        copy_with_link_target $file
    done
    FILES=`dpkg-query -L lvm2 | grep -v "\/usr\/share"`
    for file in ${FILES}
    do
        copy_with_link_target $file
    done
    FILES=`dpkg-query -L dmsetup | grep -v "\/usr\/share"`
    for file in ${FILES}
    do
        copy_with_link_target $file
    done
    FILES=`ls /lib/udev/rules.d/*`
    for file in ${FILES}
    do
        copy_with_link_target $file
    done
fi

if [ -f $GALAXY_BOOT/../syslib.tgz ]; then
    cd $DEST_PREFIX
    tar zxf $GALAXY_BOOT/../syslib.tgz
    ARCH=`uname -m`
    if [ "$ARCH" == "x86_64" ]; then
        mv x86_64/* .
    else
        mv x86/* .
    fi	
    rm -rf x86_64 x86
    cd -
fi

#oldpwd=`pwd`
#cd INITRD
#for file in `cat /tmp/1touch_initrd_skiplist`
#do
#	exclude="."$file
#	rm -rf $exclude
#done
#cd $oldpwd

#build initrd
#Copy devmapper binaries, libs and configuration files
mkdir -p ${DEST_PREFIX}/
if  [ $IS_CPIO != 1 ]; then
     cd $DEST_PREFIX
     tar -cf ../initrd.tar ./* 2>>$LOG
     cd -
     dd if=/dev/zero of=initrd bs=1k count=100352 2>> $LOG
     echo -e "\nMaking file system for INITRD"
     mke2fs -b 1024 -m 1 -i 2048 -F initrd >> $LOG
     if [ $? -ne 0 ]; then
         log="Making file system for INITRD failed. $REFER"
         echo "$log" >> $LOG
         echo "$log" > /tmp/srfailure_reason
         exit 1
     fi
     mkdir ./loop1 2>/dev/null
     mount -o loop initrd ./loop1
     cd ./loop1 
     tar -xf ../initrd.tar
     if [ $? -ne 0 ]; then
         log="Copying files for INITRD failed. $REFER"
         echo "$log" >> $LOG
         echo "$log" > /tmp/srfailure_reason
         exit 2
     fi
     cd -
     umount  ./loop1
     rm -rf initrd.tar
else
   cd $DEST_PREFIX
   (find . | cpio --quiet -c -o) > ../initrd
   if [ $? -ne 0 ]; then
       log="Creation of cpio archieve failed. $REFER"
       echo "$log" >> $LOG
       echo "$log" > /tmp/srfailure_reason
       exit 2  
   fi 
   cd - 
fi

cd ${DEST_PREFIX}/..
if [ $IS_GZIPPED == 1 ]; then
    Execute "gzip -f -v9 ./initrd"
    Execute "mv initrd.gz $INITRD_NAME"
else
    mv initrd $INITRD_NAME
fi

# Check if initrd.img size is zero. In that case, fail the backup.
if [ x`du -s $INITRD_NAME|awk '{print $1}'` == "x0" ]
then
	log="Creation of cpio archieve failed. $REFER"
    echo "$log" >> $LOG
	echo "Size of initrd.img is zero.Failing." >> $LOG
    echo "$log" > /tmp/srfailure_reason
    exit 2
fi
cd $CURDIR
rm -rf $DEST_PREFIX
echo -e "Done"
